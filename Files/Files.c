/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of Files.xs. Do not edit this file, edit Files.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Files.xs"
/* $Header: /cvsroot/macperl/perl/macos/ext/Mac/Files/Files.xs,v 1.6 2002/11/13 02:04:51 pudge Exp $
 *
 *    Copyright (c) 1996 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: Files.xs,v $
 * Revision 1.6  2002/11/13 02:04:51  pudge
 * Aieeeeee!  Big ol' Carbon update.
 *
 * Revision 1.5  2002/01/30 07:43:54  neeri
 * Check ownership of CatInfos
 *
 * Revision 1.4  2002/01/23 05:44:42  pudge
 * Update whitespace etc., from Thomas
 *
 * Revision 1.3  2000/09/12 20:18:57  pudge
 * Added all the new constants for FindFolder
 * Make FSMakeFSSpec return FSSpec even if file does not exist
 *
 * Revision 1.2  2000/09/09 22:18:26  neeri
 * Dynamic libraries compile under 5.6
 *
 * Revision 1.1  2000/08/14 03:39:30  neeri
 * Checked into Sourceforge
 *
 * Revision 1.5  1998/04/07 01:02:53  neeri
 * MacPerl 5.2.0r4b1
 *
 * Revision 1.4  1997/11/18 00:52:22  neeri
 * MacPerl 5.1.5
 *
 * Revision 1.3  1997/09/02 23:06:38  neeri
 * Added Structs, other minor fixes
 *
 * Revision 1.2  1997/06/04 22:55:46  neeri
 * Compiles fine.
 *
 * Revision 1.1  1997/04/07 20:49:37  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#endif
#include <Folders.h>
#include <Files.h>
#ifdef MACOS_TRADITIONAL
#include <GUSIFileSpec.h>
#endif
#include <Script.h>
#include <Errors.h>
#include <Aliases.h>

#define MACPERL_CATINFO	'MpCI'

typedef FSSpec			RealFSSpec;
typedef CInfoPBPtr 	CatInfo;
typedef struct {
	CInfoPBRec	fInfo;
	OSType		fOwner;
	Str63		fName;
} ExtCatInfo;

static CatInfo NewCatInfo()
{
	ExtCatInfo*	ci;
	ci = (ExtCatInfo *) malloc(sizeof(ExtCatInfo));
	ci->fOwner	= MACPERL_CATINFO;
	ci->fInfo.hFileInfo.ioNamePtr = ci->fName;
	
	return (CatInfo)ci;
}

#line 92 "Files.c"
XS(XS_Mac__Files_FInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	FInfo STRUCT;

#line 84 "Files.xs"
	 STRUCT;

	if (sv_isa( ST(0), "FInfo"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(FInfo));
	else
	    croak(" STRUCT is not of type FInfo");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* fdType */
#line 99 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, (char *) &(STRUCT.fdType), 4);
		break;
	    case 1:	  /* fdCreator */
#line 100 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, (char *) &(STRUCT.fdCreator), 4);
		break;
	    case 2:	  /* fdFlags */
#line 101 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.fdFlags));
		break;
	    case 3:	  /* fdLocation */
#line 102 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "Point", (void*)&(STRUCT.fdLocation), sizeof(Point));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* fdType */
#line 99 "Files.xs"
	 STRUCT.fdType;

	memcpy(& STRUCT.fdType, SvPV_nolen( ST(1)), sizeof(OSType));
		break;
	    case 1:	  /* fdCreator */
#line 100 "Files.xs"
	 STRUCT.fdCreator;

	memcpy(& STRUCT.fdCreator, SvPV_nolen( ST(1)), sizeof(OSType));
		break;
	    case 2:	  /* fdFlags */
#line 101 "Files.xs"
	 STRUCT.fdFlags = (unsigned short)SvUV( ST(1));
		break;
	    case 3:	  /* fdLocation */
#line 102 "Files.xs"
	 STRUCT.fdLocation;

	if (sv_isa( ST(1), "Point"))
	    memcpy(& STRUCT.fdLocation, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(Point));
	else
	    croak(" STRUCT.fdLocation is not of type Point");
		break;
	    }
#line 84 "Files.xs"
	sv_setref_pvn( ST(0), "FInfo", (void*)&( STRUCT), sizeof(FInfo));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FXInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	FXInfo STRUCT;

#line 104 "Files.xs"
	 STRUCT;

	if (sv_isa( ST(0), "FXInfo"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(FXInfo));
	else
	    croak(" STRUCT is not of type FXInfo");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* fdIconID */
#line 116 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.fdIconID));
		break;
	    case 1:	  /* fdScript */
#line 117 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.fdScript));
		break;
	    case 2:	  /* fdXFlags */
#line 118 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.fdXFlags));
		break;
	    case 3:	  /* fdComment */
#line 119 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.fdComment));
		break;
	    case 4:	  /* fdPutAway */
#line 120 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.fdPutAway));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* fdIconID */
#line 116 "Files.xs"
	 STRUCT.fdIconID = (short)SvIV( ST(1));
		break;
	    case 1:	  /* fdScript */
#line 117 "Files.xs"
	 STRUCT.fdScript = (I8)SvIV( ST(1));
		break;
	    case 2:	  /* fdXFlags */
#line 118 "Files.xs"
	 STRUCT.fdXFlags = (I8)SvIV( ST(1));
		break;
	    case 3:	  /* fdComment */
#line 119 "Files.xs"
	 STRUCT.fdComment = (short)SvIV( ST(1));
		break;
	    case 4:	  /* fdPutAway */
#line 120 "Files.xs"
	 STRUCT.fdPutAway = (long)SvIV( ST(1));
		break;
	    }
#line 104 "Files.xs"
	sv_setref_pvn( ST(0), "FXInfo", (void*)&( STRUCT), sizeof(FXInfo));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_DInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	DInfo STRUCT;

#line 122 "Files.xs"
	 STRUCT;

	if (sv_isa( ST(0), "DInfo"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(DInfo));
	else
	    croak(" STRUCT is not of type DInfo");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* frRect */
#line 133 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "Rect", (void*)&(STRUCT.frRect), sizeof(Rect));
		break;
	    case 1:	  /* frFlags */
#line 134 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT.frFlags));
		break;
	    case 2:	  /* frLocation */
#line 135 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "Point", (void*)&(STRUCT.frLocation), sizeof(Point));
		break;
	    case 3:	  /* frView */
#line 136 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.frView));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* frRect */
#line 133 "Files.xs"
	 STRUCT.frRect;

	if (sv_isa( ST(1), "Rect"))
	    memcpy(& STRUCT.frRect, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(Rect));
	else
	    croak(" STRUCT.frRect is not of type Rect");
		break;
	    case 1:	  /* frFlags */
#line 134 "Files.xs"
	 STRUCT.frFlags = (unsigned short)SvUV( ST(1));
		break;
	    case 2:	  /* frLocation */
#line 135 "Files.xs"
	 STRUCT.frLocation;

	if (sv_isa( ST(1), "Point"))
	    memcpy(& STRUCT.frLocation, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(Point));
	else
	    croak(" STRUCT.frLocation is not of type Point");
		break;
	    case 3:	  /* frView */
#line 136 "Files.xs"
	 STRUCT.frView = (short)SvIV( ST(1));
		break;
	    }
#line 122 "Files.xs"
	sv_setref_pvn( ST(0), "DInfo", (void*)&( STRUCT), sizeof(DInfo));
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_DXInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	DXInfo STRUCT;

#line 138 "Files.xs"
	 STRUCT;

	if (sv_isa( ST(0), "DXInfo"))
	    memcpy(& STRUCT, SvPV_nolen((SV*)SvRV( ST(0))), sizeof(DXInfo));
	else
	    croak(" STRUCT is not of type DXInfo");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* frScroll */
#line 151 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "Point", (void*)&(STRUCT.frScroll), sizeof(Point));
		break;
	    case 1:	  /* frOpenChain */
#line 152 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.frOpenChain));
		break;
	    case 2:	  /* frScript */
#line 153 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.frScript));
		break;
	    case 3:	  /* frXFlags */
#line 154 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.frXFlags));
		break;
	    case 4:	  /* frComment */
#line 155 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.frComment));
		break;
	    case 5:	  /* frPutAway */
#line 156 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT.frPutAway));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* frScroll */
#line 151 "Files.xs"
	 STRUCT.frScroll;

	if (sv_isa( ST(1), "Point"))
	    memcpy(& STRUCT.frScroll, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(Point));
	else
	    croak(" STRUCT.frScroll is not of type Point");
		break;
	    case 1:	  /* frOpenChain */
#line 152 "Files.xs"
	 STRUCT.frOpenChain = (long)SvIV( ST(1));
		break;
	    case 2:	  /* frScript */
#line 153 "Files.xs"
	 STRUCT.frScript = (I8)SvIV( ST(1));
		break;
	    case 3:	  /* frXFlags */
#line 154 "Files.xs"
	 STRUCT.frXFlags = (I8)SvIV( ST(1));
		break;
	    case 4:	  /* frComment */
#line 155 "Files.xs"
	 STRUCT.frComment = (short)SvIV( ST(1));
		break;
	    case 5:	  /* frPutAway */
#line 156 "Files.xs"
	 STRUCT.frPutAway = (long)SvIV( ST(1));
		break;
	    }
#line 138 "Files.xs"
	sv_setref_pvn( ST(0), "DXInfo", (void*)&( STRUCT), sizeof(DXInfo));
	}
    }
    XSRETURN(1);
}

XS(XS_CatInfo_CatInfo)
{
    dXSARGS;
    dXSI32;
    if (items < 1 || items > 2)
       croak("Usage: %s(STRUCT [, VALUE])", GvNAME(CvGV(cv)));
    SP -= items;
    {
	HFileInfo * STRUCT;

#line 167 "Files.xs"
	 *(CatInfo *)&STRUCT;

	if (sv_derived_from( ST(0), "CatInfo")) {
	    IV tmp = SvIV((SV*)SvRV( ST(0)));
	     *(CatInfo *)&STRUCT = INT2PTR(CatInfo,tmp);
	}
	else
	    croak(" *(CatInfo *)&STRUCT is not of type CatInfo");
	if (items == 1) { /* Get field */
	    switch (ix) {
	    case 0:	  /* ioNamePtr */
#line 170 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, ((char *) (STRUCT->ioNamePtr)) + 1, (STRUCT->ioNamePtr)[0]);
		break;
	    case 1:	  /* ioVRefNum */
#line 171 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioVRefNum));
		break;
	    case 2:	  /* ioFRefNum */
#line 172 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFRefNum));
		break;
	    case 3:	  /* ioFVersNum */
#line 173 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFVersNum));
		break;
	    case 4:	  /* ioFDirIndex */
#line 174 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFDirIndex));
		break;
	    case 5:	  /* ioFlAttrib */
#line 175 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlAttrib));
		break;
	    case 6:	  /* ioACUser */
#line 176 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioACUser));
		break;
	    case 7:	  /* ioFlFndrInfo */
#line 177 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "FInfo", (void*)&(STRUCT->ioFlFndrInfo), sizeof(FInfo));
		break;
	    case 8:	  /* ioDirID */
#line 178 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioDirID));
		break;
	    case 9:	  /* ioFlStBlk */
#line 179 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->ioFlStBlk));
		break;
	    case 10:	  /* ioFlLgLen */
#line 180 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlLgLen));
		break;
	    case 11:	  /* ioFlPyLen */
#line 181 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlPyLen));
		break;
	    case 12:	  /* ioFlRStBlk */
#line 182 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setuv(*sp, (UV)(STRUCT->ioFlRStBlk));
		break;
	    case 13:	  /* ioFlRLgLen */
#line 183 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlRLgLen));
		break;
	    case 14:	  /* ioFlRPyLen */
#line 184 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlRPyLen));
		break;
	    case 15:	  /* ioFlCrDat */
#line 185 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setnv(*sp, (double)(STRUCT->ioFlCrDat));
		break;
	    case 16:	  /* ioFlMdDat */
#line 186 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setnv(*sp, (double)(STRUCT->ioFlMdDat));
		break;
	    case 17:	  /* ioFlBkDat */
#line 187 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setnv(*sp, (double)(STRUCT->ioFlBkDat));
		break;
	    case 18:	  /* ioFlXFndrInfo */
#line 188 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "FXInfo", (void*)&(STRUCT->ioFlXFndrInfo), sizeof(FXInfo));
		break;
	    case 19:	  /* ioFlParID */
#line 189 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlParID));
		break;
	    case 20:	  /* ioFlClpSiz */
#line 190 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(STRUCT->ioFlClpSiz));
		break;
	    case 21:	  /* ioDrUsrWds */
#line 195 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setref_pvn( *sp, "DInfo", (void*)&( ((DirInfo *)STRUCT)->ioDrUsrWds), sizeof(DInfo));
		break;
	    case 22:	  /* ioDrDirID */
#line 200 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setiv( *sp, (IV)( ((DirInfo *)STRUCT)->ioDrDirID));
		break;
	    case 23:	  /* ioDrNmFls */
#line 205 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setuv( *sp, (UV)( ((DirInfo *)STRUCT)->ioDrNmFls));
		break;
	    case 24:	  /* ioDrCrDat */
#line 210 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setnv( *sp, (double)( ((DirInfo *)STRUCT)->ioDrCrDat));
		break;
	    case 25:	  /* ioDrMdDat */
#line 215 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setnv( *sp, (double)( ((DirInfo *)STRUCT)->ioDrMdDat));
		break;
	    case 26:	  /* ioDrBkDat */
#line 220 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setnv( *sp, (double)( ((DirInfo *)STRUCT)->ioDrBkDat));
		break;
	    case 27:	  /* ioDrFndrInfo */
#line 225 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setref_pvn( *sp, "DXInfo", (void*)&( ((DirInfo *)STRUCT)->ioDrFndrInfo), sizeof(DXInfo));
		break;
	    case 28:	  /* ioDrParID */
#line 230 "Files.xs"
	PUSHs(sv_newmortal());
	sv_setiv( *sp, (IV)( ((DirInfo *)STRUCT)->ioDrParID));
		break;
	    }
	} else { 	   /* Set field */
	    switch (ix) {
	    case 0:	  /* ioNamePtr */
#line 170 "Files.xs"
	 STRUCT->ioNamePtr;

	MacPerl_CopyC2P(SvPV_nolen( ST(1)),  STRUCT->ioNamePtr);
		break;
	    case 1:	  /* ioVRefNum */
#line 171 "Files.xs"
	 STRUCT->ioVRefNum = (short)SvIV( ST(1));
		break;
	    case 2:	  /* ioFRefNum */
#line 172 "Files.xs"
	 STRUCT->ioFRefNum = (short)SvIV( ST(1));
		break;
	    case 3:	  /* ioFVersNum */
#line 173 "Files.xs"
	 STRUCT->ioFVersNum = (I8)SvIV( ST(1));
		break;
	    case 4:	  /* ioFDirIndex */
#line 174 "Files.xs"
	 STRUCT->ioFDirIndex = (short)SvIV( ST(1));
		break;
	    case 5:	  /* ioFlAttrib */
#line 175 "Files.xs"
	 STRUCT->ioFlAttrib = (I8)SvIV( ST(1));
		break;
	    case 6:	  /* ioACUser */
#line 176 "Files.xs"
	 STRUCT->ioACUser = (I8)SvIV( ST(1));
		break;
	    case 7:	  /* ioFlFndrInfo */
#line 177 "Files.xs"
	 STRUCT->ioFlFndrInfo;

	if (sv_isa( ST(1), "FInfo"))
	    memcpy(& STRUCT->ioFlFndrInfo, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(FInfo));
	else
	    croak(" STRUCT->ioFlFndrInfo is not of type FInfo");
		break;
	    case 8:	  /* ioDirID */
#line 178 "Files.xs"
	 STRUCT->ioDirID = (long)SvIV( ST(1));
		break;
	    case 9:	  /* ioFlStBlk */
#line 179 "Files.xs"
	 STRUCT->ioFlStBlk = (unsigned short)SvUV( ST(1));
		break;
	    case 10:	  /* ioFlLgLen */
#line 180 "Files.xs"
	 STRUCT->ioFlLgLen = (long)SvIV( ST(1));
		break;
	    case 11:	  /* ioFlPyLen */
#line 181 "Files.xs"
	 STRUCT->ioFlPyLen = (long)SvIV( ST(1));
		break;
	    case 12:	  /* ioFlRStBlk */
#line 182 "Files.xs"
	 STRUCT->ioFlRStBlk = (unsigned short)SvUV( ST(1));
		break;
	    case 13:	  /* ioFlRLgLen */
#line 183 "Files.xs"
	 STRUCT->ioFlRLgLen = (long)SvIV( ST(1));
		break;
	    case 14:	  /* ioFlRPyLen */
#line 184 "Files.xs"
	 STRUCT->ioFlRPyLen = (long)SvIV( ST(1));
		break;
	    case 15:	  /* ioFlCrDat */
#line 185 "Files.xs"
	 STRUCT->ioFlCrDat = (time_t)SvNV( ST(1));
		break;
	    case 16:	  /* ioFlMdDat */
#line 186 "Files.xs"
	 STRUCT->ioFlMdDat = (time_t)SvNV( ST(1));
		break;
	    case 17:	  /* ioFlBkDat */
#line 187 "Files.xs"
	 STRUCT->ioFlBkDat = (time_t)SvNV( ST(1));
		break;
	    case 18:	  /* ioFlXFndrInfo */
#line 188 "Files.xs"
	 STRUCT->ioFlXFndrInfo;

	if (sv_isa( ST(1), "FXInfo"))
	    memcpy(& STRUCT->ioFlXFndrInfo, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(FXInfo));
	else
	    croak(" STRUCT->ioFlXFndrInfo is not of type FXInfo");
		break;
	    case 19:	  /* ioFlParID */
#line 189 "Files.xs"
	 STRUCT->ioFlParID = (long)SvIV( ST(1));
		break;
	    case 20:	  /* ioFlClpSiz */
#line 190 "Files.xs"
	 STRUCT->ioFlClpSiz = (long)SvIV( ST(1));
		break;
	    case 21:	  /* ioDrUsrWds */
#line 193 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrUsrWds;

	if (sv_isa( ST(1), "DInfo"))
	    memcpy(& ((DirInfo *)STRUCT)->ioDrUsrWds, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(DInfo));
	else
	    croak(" ((DirInfo *)STRUCT)->ioDrUsrWds is not of type DInfo");
		break;
	    case 22:	  /* ioDrDirID */
#line 198 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrDirID = (long)SvIV( ST(1));
		break;
	    case 23:	  /* ioDrNmFls */
#line 203 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrNmFls = (unsigned short)SvUV( ST(1));
		break;
	    case 24:	  /* ioDrCrDat */
#line 208 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrCrDat = (time_t)SvNV( ST(1));
		break;
	    case 25:	  /* ioDrMdDat */
#line 213 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrMdDat = (time_t)SvNV( ST(1));
		break;
	    case 26:	  /* ioDrBkDat */
#line 218 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrBkDat = (time_t)SvNV( ST(1));
		break;
	    case 27:	  /* ioDrFndrInfo */
#line 223 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrFndrInfo;

	if (sv_isa( ST(1), "DXInfo"))
	    memcpy(& ((DirInfo *)STRUCT)->ioDrFndrInfo, SvPV_nolen((SV*)SvRV( ST(1))), sizeof(DXInfo));
	else
	    croak(" ((DirInfo *)STRUCT)->ioDrFndrInfo is not of type DXInfo");
		break;
	    case 28:	  /* ioDrParID */
#line 228 "Files.xs"
	 ((DirInfo *)STRUCT)->ioDrParID = (long)SvIV( ST(1));
		break;
	    }
#line 169 "Files.xs"
	++sp;
	*sp = sv_newmortal();
	sv_setref_pv(*sp, "CatInfo", (void*)(STRUCT));
	}
    }
    XSRETURN(1);
}

XS(XS_CatInfo_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: CatInfo::DESTROY(cat)");
    {
	CatInfo	cat;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cat = INT2PTR(CatInfo,tmp);
	}
	else
	    croak("cat is not a reference");
#line 236 "Files.xs"
	if (((ExtCatInfo *)cat)->fOwner == MACPERL_CATINFO)
		free(cat);
#line 782 "Files.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_Mac__Files_FSpGetCatInfo)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpGetCatInfo(file, index=0)");
    {
	FSSpec	file;
	short	index;
	CatInfo	RETVAL;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &file))
		croak("file is not a valid file specification");
	else
		0;

	if (items < 2)
	    index = 0;
	else {
	    index = (short)SvIV(ST(1));
	}
#line 258 "Files.xs"
	if ((index && GUSIFSpUp(&file)) || !(RETVAL = NewCatInfo())) {
		XSRETURN_UNDEF;
	}
	RETVAL->hFileInfo.ioVRefNum 	= file.vRefNum;
	RETVAL->hFileInfo.ioDirID 	= file.parID;
	RETVAL->hFileInfo.ioFDirIndex	= index;
	if (!index)
		memcpy(RETVAL->hFileInfo.ioNamePtr, file.name, *file.name+1);
	if (gMacPerl_OSErr = PBGetCatInfoSync(RETVAL)) {
		free(RETVAL);
		XSRETURN_UNDEF;
	}
#ifndef MACOS_TRADITIONAL
	// takes care of Dr time fields too
	RETVAL->hFileInfo.ioFlCrDat	= SecondsMac2Unix(RETVAL->hFileInfo.ioFlCrDat);
	RETVAL->hFileInfo.ioFlMdDat	= SecondsMac2Unix(RETVAL->hFileInfo.ioFlMdDat);
	RETVAL->hFileInfo.ioFlBkDat	= SecondsMac2Unix(RETVAL->hFileInfo.ioFlBkDat);
#endif
#line 826 "Files.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "CatInfo", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpSetCatInfo)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpSetCatInfo(file, info)");
    {
	FSSpec	file;
	CatInfo	info;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &file))
		croak("file is not a valid file specification");
	else
		0;

	if (sv_derived_from(ST(1), "CatInfo")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    info = INT2PTR(CatInfo,tmp);
	}
	else
	    croak("info is not of type CatInfo");
#line 289 "Files.xs"
	info->hFileInfo.ioVRefNum 	= file.vRefNum;
	info->hFileInfo.ioDirID 	= file.parID;
#ifndef MACOS_TRADITIONAL
	// takes care of Dr time fields too
	info->hFileInfo.ioFlCrDat	= SecondsUnix2Mac(info->hFileInfo.ioFlCrDat);
	info->hFileInfo.ioFlMdDat	= SecondsUnix2Mac(info->hFileInfo.ioFlMdDat);
	info->hFileInfo.ioFlBkDat	= SecondsUnix2Mac(info->hFileInfo.ioFlBkDat);
#endif
	memcpy(info->hFileInfo.ioNamePtr, file.name, *file.name+1);
	RETVAL = PBSetCatInfoSync(info);
#line 866 "Files.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSMakeFSSpec)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSMakeFSSpec(vRefNum, dirID, fileName)");
    {
	short	vRefNum = (short)SvIV(ST(0));
	long	dirID = (long)SvIV(ST(1));
	Str255	fileName;
	RealFSSpec	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(2)), fileName);
#line 314 "Files.xs"
	gMacPerl_OSErr = FSMakeFSSpec(vRefNum, dirID, fileName, &RETVAL);
	if ((gMacPerl_OSErr != noErr) && (gMacPerl_OSErr != fnfErr)) {
		XSRETURN_UNDEF;
	}
#line 890 "Files.c"
	sv_setpv(TARG, GUSIFSp2Encoding(&RETVAL)); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpCreate)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpCreate(spec, creator, type, scriptTag=smSystemScript)");
    {
	FSSpec	spec;
	OSType	creator;
	OSType	type;
	char	scriptTag;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	memcpy(&creator, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));

	if (items < 4)
	    scriptTag = smSystemScript;
	else {
	    scriptTag = (char)*SvPV(ST(3),PL_na);
	}

	RETVAL = FSpCreate(&spec, creator, type, scriptTag);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpDirCreate)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpDirCreate(spec, scriptTag=smSystemScript)");
    {
	FSSpec	spec;
	char	scriptTag;
	long	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	if (items < 2)
	    scriptTag = smSystemScript;
	else {
	    scriptTag = (char)*SvPV(ST(1),PL_na);
	}
#line 344 "Files.xs"
	if (gMacPerl_OSErr = FSpDirCreate(&spec, scriptTag, &RETVAL))
		RETVAL = 0;
#line 954 "Files.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpDelete)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpDelete(spec)");
    {
	FSSpec	spec;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	RETVAL = FSpDelete(&spec);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpGetFInfo)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpGetFInfo(spec)");
    {
	FSSpec	spec;
	FInfo	RETVAL;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;
#line 367 "Files.xs"
	if (gMacPerl_OSErr = FSpGetFInfo(&spec, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 998 "Files.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "FInfo", (void*)&RETVAL, sizeof(FInfo));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpSetFInfo)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpSetFInfo(spec, info)");
    {
	FSSpec	spec;
	FInfo	info;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	if (sv_isa(ST(1), "FInfo"))
	    memcpy(&info, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(FInfo));
	else
	    croak("info is not of type FInfo");

	RETVAL = FSpSetFInfo(&spec, &info);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpSetFLock)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpSetFLock(spec)");
    {
	FSSpec	spec;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	RETVAL = FSpSetFLock(&spec);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpRstFLock)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpRstFLock(spec)");
    {
	FSSpec	spec;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	RETVAL = FSpRstFLock(&spec);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpRename)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpRename(spec, newName)");
    {
	FSSpec	spec;
	Str255	newName;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &spec))
		croak("spec is not a valid file specification");
	else
		0;

	MacPerl_CopyC2P(SvPV_nolen(ST(1)), newName);

	RETVAL = FSpRename(&spec, newName);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpCatMove)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpCatMove(source, dest)");
    {
	FSSpec	source;
	FSSpec	dest;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &source))
		croak("source is not a valid file specification");
	else
		0;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(1)), &dest))
		croak("dest is not a valid file specification");
	else
		0;

	RETVAL = FSpCatMove(&source, &dest);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FSpExchangeFiles)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::FSpExchangeFiles(source, dest)");
    {
	FSSpec	source;
	FSSpec	dest;
	MacOSRet	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &source))
		croak("source is not a valid file specification");
	else
		0;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(1)), &dest))
		croak("dest is not a valid file specification");
	else
		0;

	RETVAL = FSpExchangeFiles(&source, &dest);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_NewAlias)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::NewAlias(target)");
    {
	FSSpec	target;
	Handle	RETVAL;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &target))
		croak("target is not a valid file specification");
	else
		0;
#line 441 "Files.xs"
	gMacPerl_OSErr = NewAlias(nil, &target, (AliasHandle *)&RETVAL);
#line 1167 "Files.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_NewAliasRelative)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::NewAliasRelative(from, target)");
    {
	FSSpec	from;
	FSSpec	target;
	Handle	RETVAL;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &from))
		croak("from is not a valid file specification");
	else
		0;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(1)), &target))
		croak("target is not a valid file specification");
	else
		0;
#line 455 "Files.xs"
	gMacPerl_OSErr = NewAlias(&from, &target, (AliasHandle *)&RETVAL);
#line 1195 "Files.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_NewAliasMinimal)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::NewAliasMinimal(target)");
    {
	FSSpec	target;
	Handle	RETVAL;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &target))
		croak("target is not a valid file specification");
	else
		0;
#line 470 "Files.xs"
	gMacPerl_OSErr = NewAliasMinimal(&target, (AliasHandle *)&RETVAL);
#line 1217 "Files.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_NewAliasMinimalFromFullPath)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Files::NewAliasMinimalFromFullPath(name, zone=NO_INIT, server=NO_INIT)");
    {
	char *	name = (char *)SvPV(ST(0),PL_na);
	Str255	zone;
	Str255	server;
	Handle	RETVAL;

	if (items >= 2) {
	    MacPerl_CopyC2P(SvPV_nolen(ST(1)), zone);
	}

	if (items >= 3) {
	    MacPerl_CopyC2P(SvPV_nolen(ST(2)), server);
	}
#line 485 "Files.xs"
	if (items < 3)
		server[0] = 0;
	if (items < 2)
		zone[0] = 0;
	gMacPerl_OSErr = 
		NewAliasMinimalFromFullPath(strlen(name), name, zone, server, (AliasHandle *)&RETVAL);
#line 1249 "Files.c"
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_UpdateAlias)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::UpdateAlias(target, alias)");
    {
	FSSpec	target;
	Handle	alias;
	Boolean	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &target))
		croak("target is not a valid file specification");
	else
		0;

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alias = INT2PTR(Handle,tmp);
	}
	else
	    croak("alias is not of type Handle");
#line 504 "Files.xs"
	if (gMacPerl_OSErr = UpdateAlias(nil, &target, (AliasHandle) alias, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1282 "Files.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_UpdateAliasRelative)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::Files::UpdateAliasRelative(from, target, alias)");
    {
	FSSpec	from;
	FSSpec	target;
	Handle	alias;
	Boolean	RETVAL;
	dXSTARG;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &from))
		croak("from is not a valid file specification");
	else
		0;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(1)), &target))
		croak("target is not a valid file specification");
	else
		0;

	if (sv_derived_from(ST(2), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    alias = INT2PTR(Handle,tmp);
	}
	else
	    croak("alias is not of type Handle");
#line 522 "Files.xs"
	if (gMacPerl_OSErr = UpdateAlias(&from, &target, (AliasHandle) alias, &RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1320 "Files.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_ResolveAlias)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::Files::ResolveAlias(alias)");
    SP -= items;
    {
	Handle	alias;

	if (sv_derived_from(ST(0), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    alias = INT2PTR(Handle,tmp);
	}
	else
	    croak("alias is not of type Handle");
#line 538 "Files.xs"
	{
		FSSpec	target;
		Boolean	changed;

		gMacPerl_OSErr = ResolveAlias(nil, (AliasHandle) alias, &target, &changed);

		if (gMacPerl_OSErr)  {
			XSRETURN_EMPTY;
		} 
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setpv(*sp, GUSIFSp2FullPath(&(target)));
		if (GIMME == G_ARRAY) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(changed));
		}
	}
#line 1362 "Files.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Files_ResolveAliasRelative)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::ResolveAliasRelative(from, alias)");
    SP -= items;
    {
	FSSpec	from;
	Handle	alias;

	if (GUSIPath2FSp((char *) SvPV_nolen(ST(0)), &from))
		croak("from is not a valid file specification");
	else
		0;

	if (sv_derived_from(ST(1), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alias = INT2PTR(Handle,tmp);
	}
	else
	    croak("alias is not of type Handle");
#line 565 "Files.xs"
	{
		FSSpec	target;
		Boolean	changed;

		gMacPerl_OSErr = ResolveAlias(&from, (AliasHandle) alias, &target, &changed);

		if (gMacPerl_OSErr)  {
			XSRETURN_EMPTY;
		} 
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setpv(*sp, GUSIFSp2FullPath(&(target)));
		if (GIMME == G_ARRAY) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setiv(*sp, (IV)(changed));
		}
	}
#line 1410 "Files.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__Files_GetAliasInfo)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::GetAliasInfo(alias, index)");
    {
	Handle	alias;
	short	index = (short)SvIV(ST(1));
	Str255	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Handle")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    alias = INT2PTR(Handle,tmp);
	}
	else
	    croak("alias is not of type Handle");
#line 590 "Files.xs"
	if (gMacPerl_OSErr = GetAliasInfo((AliasHandle) alias, index, RETVAL)) {
		XSRETURN_UNDEF;
	}
#line 1437 "Files.c"
	XSprePUSH; PUSHp(((char *) RETVAL) + 1, RETVAL[0]);
    }
    XSRETURN(1);
}

XS(XS_Mac__Files__UnmountVol)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::_UnmountVol(volName, vRefNum)");
    {
	Str255	volName;
	short	vRefNum = (short)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(0)), volName);
#line 606 "Files.xs"
	RETVAL = UnmountVol(volName, vRefNum);
#line 1457 "Files.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files__Eject)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::_Eject(volName, vRefNum)");
    {
	Str255	volName;
	short	vRefNum = (short)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(0)), volName);
#line 620 "Files.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::Files::Eject unsupported in Carbon");
#else
	RETVAL = Eject(volName, vRefNum);
#endif
#line 1481 "Files.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files__FlushVol)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::Files::_FlushVol(volName, vRefNum)");
    {
	Str255	volName;
	short	vRefNum = (short)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	MacPerl_CopyC2P(SvPV_nolen(ST(0)), volName);
#line 638 "Files.xs"
	RETVAL = FlushVol(volName, vRefNum);
#line 1501 "Files.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__Files_FindFolder)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::Files::FindFolder(vRefNum, folderType, createFolder=0)");
    {
	short	vRefNum = (short)SvIV(ST(0));
	OSType	folderType;
	Boolean	createFolder;
	FSSpec	RETVAL;
	dXSTARG;

	memcpy(&folderType, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 3)
	    createFolder = 0;
	else {
	    createFolder = (Boolean)SvIV(ST(2));
	}
#line 655 "Files.xs"
	if (gMacPerl_OSErr = FindFolder(vRefNum, folderType, createFolder, &RETVAL.vRefNum, &RETVAL.parID)) {
		XSRETURN_UNDEF;
	}
	GUSIFSpUp(&RETVAL);
#line 1531 "Files.c"
	sv_setpv(TARG, GUSIFSp2FullPath(&RETVAL)); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__Files)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        cv = newXS("FInfo::fdType", XS_Mac__Files_FInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("FInfo::fdCreator", XS_Mac__Files_FInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("FInfo::fdFlags", XS_Mac__Files_FInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("FInfo::fdLocation", XS_Mac__Files_FInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("FXInfo::fdIconID", XS_Mac__Files_FXInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("FXInfo::fdScript", XS_Mac__Files_FXInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("FXInfo::fdXFlags", XS_Mac__Files_FXInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("FXInfo::fdComment", XS_Mac__Files_FXInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("FXInfo::fdPutAway", XS_Mac__Files_FXInfo, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("DInfo::frRect", XS_Mac__Files_DInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("DInfo::frFlags", XS_Mac__Files_DInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("DInfo::frLocation", XS_Mac__Files_DInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("DInfo::frView", XS_Mac__Files_DInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("DXInfo::frScroll", XS_Mac__Files_DXInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("DXInfo::frOpenChain", XS_Mac__Files_DXInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("DXInfo::frScript", XS_Mac__Files_DXInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("DXInfo::frXFlags", XS_Mac__Files_DXInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("DXInfo::frComment", XS_Mac__Files_DXInfo, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("DXInfo::frPutAway", XS_Mac__Files_DXInfo, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("CatInfo::ioNamePtr", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 0 ; 
        cv = newXS("CatInfo::ioVRefNum", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 1 ; 
        cv = newXS("CatInfo::ioFRefNum", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 2 ; 
        cv = newXS("CatInfo::ioFVersNum", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 3 ; 
        cv = newXS("CatInfo::ioFDirIndex", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 4 ; 
        cv = newXS("CatInfo::ioFlAttrib", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 5 ; 
        cv = newXS("CatInfo::ioACUser", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 6 ; 
        cv = newXS("CatInfo::ioFlFndrInfo", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 7 ; 
        cv = newXS("CatInfo::ioDirID", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 8 ; 
        cv = newXS("CatInfo::ioFlStBlk", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 9 ; 
        cv = newXS("CatInfo::ioFlLgLen", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 10 ; 
        cv = newXS("CatInfo::ioFlPyLen", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 11 ; 
        cv = newXS("CatInfo::ioFlRStBlk", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 12 ; 
        cv = newXS("CatInfo::ioFlRLgLen", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 13 ; 
        cv = newXS("CatInfo::ioFlRPyLen", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 14 ; 
        cv = newXS("CatInfo::ioFlCrDat", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 15 ; 
        cv = newXS("CatInfo::ioFlMdDat", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 16 ; 
        cv = newXS("CatInfo::ioFlBkDat", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 17 ; 
        cv = newXS("CatInfo::ioFlXFndrInfo", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 18 ; 
        cv = newXS("CatInfo::ioFlParID", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 19 ; 
        cv = newXS("CatInfo::ioFlClpSiz", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 20 ; 
        cv = newXS("CatInfo::ioDrUsrWds", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 21 ; 
        cv = newXS("CatInfo::ioDrDirID", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 22 ; 
        cv = newXS("CatInfo::ioDrNmFls", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 23 ; 
        cv = newXS("CatInfo::ioDrCrDat", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 24 ; 
        cv = newXS("CatInfo::ioDrMdDat", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 25 ; 
        cv = newXS("CatInfo::ioDrBkDat", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 26 ; 
        cv = newXS("CatInfo::ioDrFndrInfo", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 27 ; 
        cv = newXS("CatInfo::ioDrParID", XS_CatInfo_CatInfo, file);
        XSANY.any_i32 = 28 ; 
        newXS("CatInfo::DESTROY", XS_CatInfo_DESTROY, file);
        newXS("Mac::Files::FSpGetCatInfo", XS_Mac__Files_FSpGetCatInfo, file);
        newXS("Mac::Files::FSpSetCatInfo", XS_Mac__Files_FSpSetCatInfo, file);
        newXS("Mac::Files::FSMakeFSSpec", XS_Mac__Files_FSMakeFSSpec, file);
        newXS("Mac::Files::FSpCreate", XS_Mac__Files_FSpCreate, file);
        newXS("Mac::Files::FSpDirCreate", XS_Mac__Files_FSpDirCreate, file);
        newXS("Mac::Files::FSpDelete", XS_Mac__Files_FSpDelete, file);
        newXS("Mac::Files::FSpGetFInfo", XS_Mac__Files_FSpGetFInfo, file);
        newXS("Mac::Files::FSpSetFInfo", XS_Mac__Files_FSpSetFInfo, file);
        newXS("Mac::Files::FSpSetFLock", XS_Mac__Files_FSpSetFLock, file);
        newXS("Mac::Files::FSpRstFLock", XS_Mac__Files_FSpRstFLock, file);
        newXS("Mac::Files::FSpRename", XS_Mac__Files_FSpRename, file);
        newXS("Mac::Files::FSpCatMove", XS_Mac__Files_FSpCatMove, file);
        newXS("Mac::Files::FSpExchangeFiles", XS_Mac__Files_FSpExchangeFiles, file);
        newXS("Mac::Files::NewAlias", XS_Mac__Files_NewAlias, file);
        newXS("Mac::Files::NewAliasRelative", XS_Mac__Files_NewAliasRelative, file);
        newXS("Mac::Files::NewAliasMinimal", XS_Mac__Files_NewAliasMinimal, file);
        newXS("Mac::Files::NewAliasMinimalFromFullPath", XS_Mac__Files_NewAliasMinimalFromFullPath, file);
        newXS("Mac::Files::UpdateAlias", XS_Mac__Files_UpdateAlias, file);
        newXS("Mac::Files::UpdateAliasRelative", XS_Mac__Files_UpdateAliasRelative, file);
        newXS("Mac::Files::ResolveAlias", XS_Mac__Files_ResolveAlias, file);
        newXS("Mac::Files::ResolveAliasRelative", XS_Mac__Files_ResolveAliasRelative, file);
        newXS("Mac::Files::GetAliasInfo", XS_Mac__Files_GetAliasInfo, file);
        newXS("Mac::Files::_UnmountVol", XS_Mac__Files__UnmountVol, file);
        newXS("Mac::Files::_Eject", XS_Mac__Files__Eject, file);
        newXS("Mac::Files::_FlushVol", XS_Mac__Files__FlushVol, file);
        newXS("Mac::Files::FindFolder", XS_Mac__Files_FindFolder, file);
    XSRETURN_YES;
}

