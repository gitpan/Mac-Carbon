/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of AppleEvents.xs. Do not edit this file, edit AppleEvents.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "AppleEvents.xs"
/* $Header: /cvsroot/macperl/perl/macos/ext/Mac/AppleEvents/AppleEvents.xs,v 1.2 2000/09/09 22:18:25 neeri Exp $
 *
 *    Copyright (c) 1996 Matthias Neeracher
 *
 *    You may distribute under the terms of the Perl Artistic License,
 *    as specified in the README file.
 *
 * $Log: AppleEvents.xs,v $
 * Revision 1.2  2000/09/09 22:18:25  neeri
 * Dynamic libraries compile under 5.6
 *
 * Revision 1.1  2000/08/14 01:48:18  neeri
 * Checked into Sourceforge
 *
 * Revision 1.3  1999/06/03 19:22:05  pudge
 * Add AEPutKey, AEPutKeyDesc, AEGetKeyDesc functions.  Inline constant subroutines.
 *
 * Revision 1.2  1997/11/18 00:52:07  neeri
 * MacPerl 5.1.5
 *
 * Revision 1.1  1997/04/07 20:49:07  neeri
 * Synchronized with MacPerl 5.1.4a1
 *
 */

#define MAC_CONTEXT

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifndef MACOS_TRADITIONAL
#include "../Carbon.h"
#include "CarbonAE.h"
#endif
#include <stdarg.h>
#include <Types.h>
#include <Memory.h>
#include <AppleEvents.h>
#include "PerlAEUtils.h"
#ifdef MACOS_TRADITIONAL
#include "SubLaunch.h"
#endif

typedef int 	SysRet;
typedef long	SysRetLong;

#define AEFail(error)	if (gMacPerl_OSErr = (error)) { XSRETURN_UNDEF; } else 0

#line 59 "AppleEvents.c"
XS(XS_AEDesc__new)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: AEDesc::_new(package, type='null', data=0)");
    {
	SV *	package = ST(0);
	OSType	type;
	Handle	data;
	AEDesc	RETVAL;

	if (items < 2)
	    type = 'null';
	else {
	    memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	}

	if (items < 3)
	    data = 0;
	else {
	    if (sv_derived_from(ST(2), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(2)));
		data = INT2PTR(Handle,tmp);
	    }
	    else
		croak("data is not of type Handle");
	}
#line 57 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
		RETVAL.descriptorType	=	type;
		RETVAL.dataHandle			=	data;
#else
		Ptr  theData;
		Size theLength;

		AEFail(AECreateDesc(type, *data, GetHandleSize(data), &RETVAL));

		theLength = AEGetDescDataSize(&RETVAL);
		theData = malloc(theLength);
		if (theData != NULL) {
			AEFail(AEGetDescData(&RETVAL, theData, theLength));
			printf("%d:%s:%d\n", theLength, theData, strlen(theData));
		}
		printf("%s", RETVAL.dataHandle);
#endif
	}
#line 107 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_AEDesc_type)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEDesc::type(desc, newType=0)");
    {
	AEDesc	desc;
	OSType	newType;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");

	if (items < 2)
	    newType = 0;
	else {
	    memcpy(&newType, SvPV_nolen(ST(1)), sizeof(OSType));
	}
#line 84 "AppleEvents.xs"
	{
		if (items>1)
			desc.descriptorType	=	newType;
		RETVAL = desc.descriptorType;
	}
#line 141 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEDesc", (void*)&desc, sizeof(AEDesc));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHp((char *) &RETVAL, 4);
    }
    XSRETURN(1);
}

XS(XS_AEDesc_data)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEDesc::data(desc, newData=0)");
    {
	AEDesc	desc;
	Handle	newData;
	Handle	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");

	if (items < 2)
	    newData = 0;
	else {
	    if (sv_derived_from(ST(1), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		newData = INT2PTR(Handle,tmp);
	    }
	    else
		croak("newData is not of type Handle");
	}
#line 98 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
		if (items>1)
			desc.dataHandle	=	newData;
		RETVAL = desc.dataHandle;
#else
		if (items>1) {
			AEReplaceDescData(desc.descriptorType, *newData,
				GetHandleSize(newData), &desc);
		}
		char * descData;
		STRLEN descLen;

		descLen = AEGetDescDataSize(&desc);
		descData = NewPtr(descLen);
		AEGetDescData(&desc, descData, descLen);
		PtrToHand(descData, &RETVAL, strlen(descData));
#endif
	}
#line 194 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEDesc", (void*)&desc, sizeof(AEDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc__new)
{
    dXSARGS;
    if (items < 1 || items > 4)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::_new(package, key=0, type='null', data=0)");
    {
	SV *	package = ST(0);
	OSType	key;
	OSType	type;
	Handle	data;
	AEKeyDesc	RETVAL;

	if (items < 2)
	    key = 0;
	else {
	    memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
	}

	if (items < 3)
	    type = 'null';
	else {
	    memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));
	}

	if (items < 4)
	    data = 0;
	else {
	    if (sv_derived_from(ST(3), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(3)));
		data = INT2PTR(Handle,tmp);
	    }
	    else
		croak("data is not of type Handle");
	}
#line 130 "AppleEvents.xs"
	{
		RETVAL.descKey								=	key;
#ifdef MACOS_TRADITIONAL
		RETVAL.descContent.descriptorType	=	type;
		RETVAL.descContent.dataHandle			=	data;
#else
		AEReplaceDescData(type, *data, GetHandleSize(data), &RETVAL.descContent);
#endif
	}
#line 247 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&RETVAL, sizeof(AEKeyDesc));
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_key)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::key(desc, newKey=0)");
    {
	AEKeyDesc	desc;
	OSType	newKey;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");

	if (items < 2)
	    newKey = 0;
	else {
	    memcpy(&newKey, SvPV_nolen(ST(1)), sizeof(OSType));
	}
#line 147 "AppleEvents.xs"
	{
		if (items>1)
			desc.descKey	=	newKey;
		RETVAL = desc.descKey;
	}
#line 281 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHp((char *) &RETVAL, 4);
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_type)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::type(desc, newType=0)");
    {
	AEKeyDesc	desc;
	OSType	newType;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");

	if (items < 2)
	    newType = 0;
	else {
	    memcpy(&newType, SvPV_nolen(ST(1)), sizeof(OSType));
	}
#line 161 "AppleEvents.xs"
	{
		if (items>1)
			desc.descContent.descriptorType	=	newType;
		RETVAL = desc.descContent.descriptorType;
	}
#line 316 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHp((char *) &RETVAL, 4);
    }
    XSRETURN(1);
}

XS(XS_AEKeyDesc_data)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEKeyDesc::data(desc, newData=0)");
    {
	AEKeyDesc	desc;
	Handle	newData;
	Handle	RETVAL;

	if (sv_isa(ST(0), "AEKeyDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEKeyDesc));
	else
	    croak("desc is not of type AEKeyDesc");

	if (items < 2)
	    newData = 0;
	else {
	    if (sv_derived_from(ST(1), "Handle")) {
		IV tmp = SvIV((SV*)SvRV(ST(1)));
		newData = INT2PTR(Handle,tmp);
	    }
	    else
		croak("newData is not of type Handle");
	}
#line 175 "AppleEvents.xs"
	{
#ifdef MACOS_TRADITIONAL
		if (items>1)
			desc.descContent.dataHandle	=	newData;
		RETVAL = desc.descContent.dataHandle;
#else
		if (items>1) {
			AEReplaceDescData(desc.descContent.descriptorType, *newData,
				GetHandleSize(newData), &desc.descContent);
		}
		char * descData;
		STRLEN descLen;

		descLen = AEGetDescDataSize(&desc.descContent);
		descData = NewPtr(descLen);
		AEGetDescData(&desc.descContent, descData, descLen);
		PtrToHand(descData, &RETVAL, strlen(descData));
#endif
	}
#line 369 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEKeyDesc", (void*)&desc, sizeof(AEKeyDesc));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pv(ST(0), "Handle", (void*)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECreateDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECreateDesc(typeCode, data)");
    {
	OSType	typeCode;
	SV *	data = ST(1);
	AEDesc	RETVAL;

	memcpy(&typeCode, SvPV_nolen(ST(0)), sizeof(OSType));
#line 215 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;

		dataPtr = SvPV(data, dataSize);

		AEFail(AECreateDesc(typeCode, dataPtr, dataSize, &RETVAL));
	}
#line 398 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECoerce)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECoerce(typeCode, data, toType)");
    {
	OSType	typeCode;
	SV *	data = ST(1);
	OSType	toType;
	AEDesc	RETVAL;

	memcpy(&typeCode, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&toType, SvPV_nolen(ST(2)), sizeof(OSType));
#line 240 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;

		dataPtr = SvPV(data, dataSize);
		AEFail(AECoercePtr(typeCode, dataPtr, dataSize, toType, &RETVAL));
	}
#line 427 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECoerceDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECoerceDesc(theAEDesc, toType)");
    {
	AEDesc	theAEDesc;
	OSType	toType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	memcpy(&toType, SvPV_nolen(ST(1)), sizeof(OSType));
#line 255 "AppleEvents.xs"
	AEFail(AECoerceDesc(&theAEDesc, toType, &RETVAL));
#line 452 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDisposeDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDisposeDesc(theAEDesc)");
    {
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEDisposeDesc(&theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDuplicateDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDuplicateDesc(theAEDesc)");
    {
	AEDesc	theAEDesc;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");
#line 287 "AppleEvents.xs"
	AEFail(AEDuplicateDesc(&theAEDesc, &RETVAL));
#line 495 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECreateList)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECreateList(factoring, isRecord)");
    {
	SV *	factoring = ST(0);
	Boolean	isRecord = (Boolean)SvIV(ST(1));
	AEDesc	RETVAL;
#line 308 "AppleEvents.xs"
	{
		void *	factoringPtr;
		STRLEN	factoredSize;

		factoringPtr 	= 	SvPV(factoring, factoredSize);
		AEFail(AECreateList(factoringPtr, factoredSize, isRecord, &RETVAL));
	}
#line 519 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECountItems)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECountItems(theAEDescList)");
    {
	AEDesc	theAEDescList;
	SysRetLong	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");
#line 328 "AppleEvents.xs"
	AEFail(AECountItems(&theAEDescList, &RETVAL));
#line 541 "AppleEvents.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPut)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPut(theAEDescList, index, typeCode, data)");
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
#line 348 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;

		dataPtr 	= 	SvPV(data, dataSize);
		RETVAL	=	AEPutPtr(&theAEDescList, index, typeCode, dataPtr, dataSize);
	}
#line 580 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutDesc(theAEDescList, index, theAEDesc)");
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutDesc(&theAEDescList, index, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutKey)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutKey(theAERecord, theAEKeyword, typeCode, data)");
    {
	AEDesc	theAERecord;
	OSType	theAEKeyword;
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAERecord, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAERecord is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
#line 381 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;

		dataPtr		=	SvPV(data, dataSize);
		RETVAL	=	AEPutKeyPtr(&theAERecord, theAEKeyword, typeCode, dataPtr, dataSize);
	}
#line 643 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutKeyDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutKeyDesc(theAERecord, theAEKeyword, theAEDesc)");
    {
	AEDesc	theAERecord;
	OSType	theAEKeyword;
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAERecord, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAERecord is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutKeyDesc(&theAERecord, theAEKeyword, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetNthDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetNthDesc(theAEDescList, index, desiredType=typeWildCard)");
    SP -= items;
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	OSType	desiredType;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	}
#line 416 "AppleEvents.xs"
	{
		OSType 	kw;
		AEDesc	desc;

		AEFail(AEGetNthDesc(&theAEDescList, index, desiredType, &kw, &desc));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "AEDesc", (void*)&(desc), sizeof(AEDesc));
		if (GIMME == G_ARRAY && kw != typeWildCard) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, (char *) &(kw), 4);
		}
	}
#line 717 "AppleEvents.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__AppleEvents_AEGetKeyDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetKeyDesc(theAEDescList, theAEKeyword, desiredType=typeWildCard)");
    {
	AEDesc	theAEDescList;
	OSType	theAEKeyword;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	}
#line 439 "AppleEvents.xs"
	AEFail(AEGetKeyDesc(&theAEDescList, theAEKeyword, desiredType, &RETVAL));
#line 748 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDeleteItem)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDeleteItem(theAEDescList, index)");
    {
	AEDesc	theAEDescList;
	long	index = (long)SvIV(ST(1));
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAEDescList, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAEDescList is not of type AEDesc");

	RETVAL = AEDeleteItem(&theAEDescList, index);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutParam)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutParam(theAppleEvent, theAEKeyword, typeCode, data)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
#line 469 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;

		dataPtr 	= 	SvPV(data, dataSize);
		RETVAL	=	AEPutParamPtr(&theAppleEvent, theAEKeyword, typeCode, dataPtr, dataSize);
	}
#line 806 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutParamDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutParamDesc(theAppleEvent, theAEKeyword, theAEDesc)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutParamDesc(&theAppleEvent, theAEKeyword, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetParamDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetParamDesc(theAppleEvent, theAEKeyword, desiredType=typeWildCard)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	}
#line 498 "AppleEvents.xs"
	AEFail(AEGetParamDesc(&theAppleEvent, theAEKeyword, desiredType, &RETVAL));
#line 867 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDeleteParam)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDeleteParam(theAppleEvent, theAEKeyword)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	RETVAL = AEDeleteParam(&theAppleEvent, theAEKeyword);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetAttributeDesc)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetAttributeDesc(theAppleEvent, theAEKeyword, desiredType=typeWildCard)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 3)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(2)), sizeof(OSType));
	}
#line 525 "AppleEvents.xs"
	AEFail(AEGetAttributeDesc(&theAppleEvent, theAEKeyword, desiredType, &RETVAL));
#line 923 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutAttribute)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutAttribute(theAppleEvent, theAEKeyword, typeCode, data)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	OSType	typeCode;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&typeCode, SvPV_nolen(ST(2)), sizeof(OSType));
#line 546 "AppleEvents.xs"
	{
		void *	dataPtr;
		STRLEN	dataSize;

		dataPtr 	= 	SvPV(data, dataSize);
		RETVAL	=	AEPutAttributePtr(&theAppleEvent, theAEKeyword, typeCode, dataPtr, dataSize);
	}
#line 959 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPutAttributeDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPutAttributeDesc(theAppleEvent, theAEKeyword, theAEDesc)");
    {
	AEDesc	theAppleEvent;
	OSType	theAEKeyword;
	AEDesc	theAEDesc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	memcpy(&theAEKeyword, SvPV_nolen(ST(1)), sizeof(OSType));

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&theAEDesc, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("theAEDesc is not of type AEDesc");

	RETVAL = AEPutAttributeDesc(&theAppleEvent, theAEKeyword, &theAEDesc);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECreateAppleEvent)
{
    dXSARGS;
    if (items < 3 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECreateAppleEvent(theAEEventClass, theAEEventID, target, returnID=kAutoGenerateReturnID, transactionID=0)");
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	AEDesc	target;
	short	returnID;
	long	transactionID;
	AEDesc	RETVAL;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));

	if (sv_isa(ST(2), "AEDesc"))
	    memcpy(&target, SvPV_nolen((SV*)SvRV(ST(2))), sizeof(AEDesc));
	else
	    croak("target is not of type AEDesc");

	if (items < 4)
	    returnID = kAutoGenerateReturnID;
	else {
	    returnID = (short)SvIV(ST(3));
	}

	if (items < 5)
	    transactionID = 0;
	else {
	    transactionID = (long)SvIV(ST(4));
	}
#line 577 "AppleEvents.xs"
	if (gPAECreate)
		AEFail(
			CallOSACreateAppleEventProc(gPAECreate,
				theAEEventClass, theAEEventID, 
				&target, returnID, transactionID, &RETVAL, 
				gPAECreateRefCon));
	else
		AEFail(
			AECreateAppleEvent(
				theAEEventClass, theAEEventID, 
				&target, returnID, transactionID, &RETVAL));
#line 1040 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESend)
{
    dXSARGS;
    if (items < 2 || items > 4)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESend(theAppleEvent, sendMode, sendPriority=kAENormalPriority, timeout=kAEDefaultTimeout)");
    {
	AEDesc	theAppleEvent;
	long	sendMode = (long)SvIV(ST(1));
	short	sendPriority;
	long	timeout;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	if (items < 3)
	    sendPriority = kAENormalPriority;
	else {
	    sendPriority = (short)SvIV(ST(2));
	}

	if (items < 4)
	    timeout = kAEDefaultTimeout;
	else {
	    timeout = (long)SvIV(ST(3));
	}
#line 606 "AppleEvents.xs"
#ifdef MACOS_TRADITIONAL
	if (gPAESend) 
		AEFail(
			CallOSASendProc(gPAESend,
				&theAppleEvent, &RETVAL, 
				sendMode, sendPriority, timeout, (AEIdleUPP) &uSubLaunchIdle, nil,
				gPAESendRefCon));
	else
		AEFail(
			AESend(
				&theAppleEvent, &RETVAL, 
				sendMode, sendPriority, timeout, (AEIdleUPP) &uSubLaunchIdle, nil));
#else
	// AESendMessage code for Mac OS X from Steve Zellers
	mach_port_t port;
	mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
	AEPutAttributePtr(&theAppleEvent, keyReplyPortAttr, typeMachPort, &port, sizeof(port));
	AEFail(
		AESendMessage(
			&theAppleEvent, &RETVAL, 
			sendMode, timeout
		)
	);
	mach_port_destroy(mach_task_self(), port);
#endif
#line 1101 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEResetTimer)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEResetTimer(reply)");
    {
	AEDesc	reply;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&reply, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("reply is not of type AEDesc");

	RETVAL = AEResetTimer(&reply);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESuspendTheCurrentEvent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESuspendTheCurrentEvent(theAppleEvent)");
    {
	AEDesc	theAppleEvent;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	RETVAL = AESuspendTheCurrentEvent(&theAppleEvent);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEResumeTheCurrentEvent)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEResumeTheCurrentEvent(theAppleEvent, flags=kAENoDispatch, handlerRefcon=0)");
    {
	AEDesc	theAppleEvent;
	long	flags;
	long	handlerRefcon;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	if (items < 2)
	    flags = kAENoDispatch;
	else {
	    flags = (long)SvIV(ST(1));
	}

	if (items < 3)
	    handlerRefcon = 0;
	else {
	    handlerRefcon = (long)SvIV(ST(2));
	}
#line 674 "AppleEvents.xs"
	AEFail(
		AEResumeTheCurrentEvent(
			&theAppleEvent, &RETVAL, (AEEventHandlerUPP) flags, handlerRefcon));
#line 1181 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetTheCurrentEvent)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetTheCurrentEvent()");
    {
	AEDesc	RETVAL;
#line 688 "AppleEvents.xs"
	AEFail(AEGetTheCurrentEvent(&RETVAL));
#line 1197 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESetTheCurrentEvent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESetTheCurrentEvent(theAppleEvent)");
    {
	AEDesc	theAppleEvent;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theAppleEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theAppleEvent is not of type AEDesc");

	RETVAL = AESetTheCurrentEvent(&theAppleEvent);
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetInteractionAllowed)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetInteractionAllowed()");
    {
	SysRet	RETVAL;
#line 712 "AppleEvents.xs"
	{
		char	level;

		AEFail(AEGetInteractionAllowed((AEInteractAllowed *)&level));
		RETVAL = level;
	}
#line 1239 "AppleEvents.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESetInteractionAllowed)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESetInteractionAllowed(level)");
    {
	char	level = (char)*SvPV(ST(0),PL_na);
	MacOSRet	RETVAL;
	dXSTARG;
#line 731 "AppleEvents.xs"
	RETVAL = AESetInteractionAllowed((AEInteractAllowed)level);
#line 1262 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEInstallEventHandler)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEInstallEventHandler(theAEEventClass, theAEEventID, handler, handlerRefcon, isSysHandler=0)");
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	SV *	handler = ST(2);
	SV *	handlerRefcon = ST(3);
	Boolean	isSysHandler;
	MacOSRet	RETVAL;
	dXSTARG;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 5)
	    isSysHandler = 0;
	else {
	    isSysHandler = (Boolean)SvIV(ST(4));
	}
#line 765 "AppleEvents.xs"
	{
		RETVAL = PAEInstallEventHandler(theAEEventClass, theAEEventID, handler, handlerRefcon, isSysHandler);
	}
#line 1295 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AERemoveEventHandler)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AERemoveEventHandler(theAEEventClass, theAEEventID, isSysHandler=0)");
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	Boolean	isSysHandler;
	MacOSRet	RETVAL;
	dXSTARG;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 3)
	    isSysHandler = 0;
	else {
	    isSysHandler = (Boolean)SvIV(ST(2));
	}
#line 783 "AppleEvents.xs"
	RETVAL = PAERemoveEventHandler(theAEEventClass, theAEEventID, isSysHandler);
#line 1324 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetEventHandler)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetEventHandler(theAEEventClass, theAEEventID, isSysHandler=0)");
    SP -= items;
    {
	OSType	theAEEventClass;
	OSType	theAEEventID;
	Boolean	isSysHandler;

	memcpy(&theAEEventClass, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&theAEEventID, SvPV_nolen(ST(1)), sizeof(OSType));

	if (items < 3)
	    isSysHandler = 0;
	else {
	    isSysHandler = (Boolean)SvIV(ST(2));
	}
#line 801 "AppleEvents.xs"
	{
		SV * handler = sv_newmortal();
		SV * refCon  = sv_newmortal();

		AEFail(
			PAEGetEventHandler(
				theAEEventClass, theAEEventID, handler, refCon, isSysHandler));
		XPUSHs(handler);
		if (GIMME == G_ARRAY) {
			XPUSHs(refCon);
		}
	}
#line 1363 "AppleEvents.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__AppleEvents_AEManagerInfo)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEManagerInfo(keyWord)");
    {
	OSType	keyWord;
	SysRetLong	RETVAL;

	memcpy(&keyWord, SvPV_nolen(ST(0)), sizeof(OSType));
#line 827 "AppleEvents.xs"
	AEFail(AEManagerInfo(keyWord, &RETVAL));
#line 1381 "AppleEvents.c"
	ST(0) = sv_newmortal();
	if (RETVAL != -1) {
	    if (RETVAL == 0)
		sv_setpvn(ST(0), "0 but true", 10);
	    else
		sv_setiv(ST(0), (IV)RETVAL);
	}
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEBuild)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEBuild(format, ...)");
    {
	char *	format = (char *)SvPV(ST(0),PL_na);
	AEDesc	RETVAL;
#line 849 "AppleEvents.xs"
	{
		int	item = 1;
		char *formscan = format;

		PAEClearArgs();
		for (;item<items;++item) 
			if (!PAEDoNextParam(&formscan, ST(item)))
				croak("Too many arguments to AEBuild()");

		if (PAENextParam(&formscan))
			croak("Not enough arguments to AEBuild()");
		gMacPerl_OSErr = vAEBuild(&RETVAL, format, gPAEArgs);
#ifndef MACOS_TRADITIONAL
		pAEBuildError();
#endif
		AEFail(gMacPerl_OSErr);
	}
#line 1419 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEBuildParameters)
{
    dXSARGS;
    if (items < 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEBuildParameters(event, format, ...)");
    {
	AEDesc	event;
	char *	format = (char *)SvPV(ST(1),PL_na);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&event, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("event is not of type AEDesc");
#line 883 "AppleEvents.xs"
	{
		int	item = 2;
		char *formscan = format;

		PAEClearArgs();
		for (;item<items;++item) 
			if (!PAEDoNextParam(&formscan, ST(item)))
				croak("Too many arguments to AEBuildParameters()");

		if (PAENextParam(&formscan))
			croak("Not enough arguments to AEBuildParameters()");
		RETVAL = vAEBuildParameters(&event, format, gPAEArgs);
#ifndef MACOS_TRADITIONAL
		pAEBuildError();
#endif
	}
#line 1458 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEBuildAppleEvent)
{
    dXSARGS;
    if (items < 7)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEBuildAppleEvent(theClass, theID, addressType, address, returnID, transactionID, paramsFmt, ...)");
    {
	OSType	theClass;
	OSType	theID;
	OSType	addressType;
	SV *	address = ST(3);
	short	returnID = (short)SvIV(ST(4));
	long	transactionID = (long)SvIV(ST(5));
	char *	paramsFmt = (char *)SvPV(ST(6),PL_na);
	AEDesc	RETVAL;

	memcpy(&theClass, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&theID, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&addressType, SvPV_nolen(ST(2)), sizeof(OSType));
#line 917 "AppleEvents.xs"
	{
		int		item = 7;
		char *	formscan = paramsFmt;
		char *	addressPtr;
		STRLEN	addressLen;
		AEDesc	targetDesc;

		PAEClearArgs();
		addressPtr = SvPV(address, addressLen);
		for (;item<items;++item) 
			if (!PAEDoNextParam(&formscan, ST(item)))
				croak("Too many arguments to AEBuildAppleEvent()");

		if (PAENextParam(&formscan))
			croak("Not enough arguments to AEBuildAppleEvent()");
		AEFail(AECreateDesc(addressType, addressPtr, addressLen, &targetDesc));
		if (gPAECreate)
			AEFail(
				CallOSACreateAppleEventProc(gPAECreate,
					theClass, theID, 
					&targetDesc, returnID, transactionID, &RETVAL, 
					gPAECreateRefCon));
		else
			AEFail(
				AECreateAppleEvent(
					theClass, theID, 
					&targetDesc, returnID, transactionID, &RETVAL));
		AEDisposeDesc(&targetDesc);
		gMacPerl_OSErr = vAEBuildParameters(&RETVAL, paramsFmt, gPAEArgs);
#ifndef MACOS_TRADITIONAL
		pAEBuildError();
#endif
		AEFail(gMacPerl_OSErr);
	}
#line 1519 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEPrint)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEPrint(desc)");
    {
	AEDesc	desc;
	SV *	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");
#line 964 "AppleEvents.xs"
	{
		long		length;
#ifndef MACOS_TRADITIONAL
		Handle	hand;

		AEPrintDescToHandle(&desc, &hand);
		length = GetHandleSize(hand);
		RETVAL = newSVpv(*hand, length);
#else

		AEFail(AEPrintSize(&desc, &length));
		RETVAL = newSVpv("", length);
		AEPrint(&desc, SvPVX(RETVAL), length);
		SvCUR(RETVAL) = length-1;
#endif
	}
#line 1556 "AppleEvents.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEDescToSubDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEDescToSubDesc(desc)");
    {
	AEDesc	desc;
	AESubDesc	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");
#line 1000 "AppleEvents.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEDescToSubDesc unsupported in Carbon");
#else
	AEDescToSubDesc(&desc, &RETVAL);
#endif
#line 1582 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AESubDesc", (void*)&RETVAL, sizeof(AESubDesc));
    }
    XSRETURN(1);
}

#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAA 1

XS(XS_Mac__AppleEvents_AEGetSubDescType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1020 "AppleEvents.xs"
	croak("Usage: Mac::AppleEvents::AEGetSubDescType unsupported in Carbon");
#line 1608 "AppleEvents.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAB 1

XS(XS_Mac__AppleEvents_AEGetSubDescType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	RETVAL = AEGetSubDescType(&subdesc);
	XSprePUSH; PUSHp((char *) &RETVAL, 4);
    }
    XSRETURN(1);
}

#endif
#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAC 1

XS(XS_Mac__AppleEvents_AEGetSubDescBasicType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescBasicType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1043 "AppleEvents.xs"
	croak("Usage: Mac::AppleEvents::AEGetSubDescBasicType unsupported in Carbon");
#line 1657 "AppleEvents.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAD 1

XS(XS_Mac__AppleEvents_AEGetSubDescBasicType)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescBasicType(subdesc)");
    {
	AESubDesc	subdesc;
	OSType	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	RETVAL = AEGetSubDescBasicType(&subdesc);
	XSprePUSH; PUSHp((char *) &RETVAL, 4);
    }
    XSRETURN(1);
}

#endif
#ifndef MACOS_TRADITIONAL
#define XSubPPtmpAAAE 1

XS(XS_Mac__AppleEvents_AESubDescIsListOrRecord)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESubDescIsListOrRecord(subdesc)");
    {
	AESubDesc	subdesc;
	Boolean	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1065 "AppleEvents.xs"
	croak("Usage: Mac::AppleEvents::AESubDescIsListOrRecord unsupported in Carbon");
#line 1706 "AppleEvents.c"
    }
    XSRETURN(1);
}

#else
#define XSubPPtmpAAAF 1

XS(XS_Mac__AppleEvents_AESubDescIsListOrRecord)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESubDescIsListOrRecord(subdesc)");
    {
	AESubDesc	subdesc;
	Boolean	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	RETVAL = AESubDescIsListOrRecord(&subdesc);
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#endif
XS(XS_Mac__AppleEvents_AEGetSubDescData)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetSubDescData(subdesc)");
    {
	AESubDesc	subdesc;
	SV *	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1084 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEGetSubDescData unsupported in Carbon");
#else
		void *data;
		long	length;

		data		= AEGetSubDescData(&subdesc, &length);
		RETVAL	= newSVpv(data, length);
#endif
	}
#line 1761 "AppleEvents.c"
	ST(0) = RETVAL;
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AESubDescToDesc)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AESubDescToDesc(subdesc, desiredType=typeWildCard)");
    {
	AESubDesc	subdesc;
	OSType	desiredType;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	if (items < 2)
	    desiredType = typeWildCard;
	else {
	    memcpy(&desiredType, SvPV_nolen(ST(1)), sizeof(OSType));
	}
#line 1108 "AppleEvents.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AESubDescToDesc unsupported in Carbon");
#else
	AEFail(AESubDescToDesc(&subdesc, desiredType, &RETVAL));
#endif
#line 1794 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AECountSubDescItems)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AECountSubDescItems(subdesc)");
    {
	AESubDesc	subdesc;
	long	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1125 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AECountSubDescItems unsupported in Carbon");
#else
		RETVAL = AECountSubDescItems(&subdesc);
		if (RETVAL < 0)
			AEFail((OSErr) RETVAL);
#endif
	}
#line 1825 "AppleEvents.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_Mac__AppleEvents_AEGetNthSubDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetNthSubDesc(subdesc, index)");
    SP -= items;
    {
	AESubDesc	subdesc;
	long	index = (long)SvIV(ST(1));

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");
#line 1148 "AppleEvents.xs"
	{
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEGetNthSubDesc unsupported in Carbon");
#else
		OSType		kw;
		AESubDesc	sub;

		AEFail(AEGetNthSubDesc(&subdesc, index, &kw, &sub));
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setref_pvn(*sp, "AESubDesc", (void*)&(sub), sizeof(AESubDesc));
		if (GIMME == G_ARRAY && kw != typeWildCard) {
	EXTEND(sp, 1);
	++sp;
	*sp = sv_newmortal();
	sv_setpvn(*sp, (char *) &(kw), 4);
		}
#endif
	}
#line 1866 "AppleEvents.c"
	PUTBACK;
	return;
    }
}

XS(XS_Mac__AppleEvents_AEGetKeySubDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Mac::AppleEvents::AEGetKeySubDesc(subdesc, kw)");
    {
	AESubDesc	subdesc;
	OSType	kw;
	AESubDesc	RETVAL;

	if (sv_isa(ST(0), "AESubDesc"))
	    memcpy(&subdesc, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AESubDesc));
	else
	    croak("subdesc is not of type AESubDesc");

	memcpy(&kw, SvPV_nolen(ST(1)), sizeof(OSType));
#line 1175 "AppleEvents.xs"
#ifndef MACOS_TRADITIONAL
	croak("Usage: Mac::AppleEvents::AEGetNthSubDesc unsupported in Carbon");
#else
	AEFail(AEGetKeySubDesc(&subdesc, kw, &RETVAL));
#endif
#line 1894 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AESubDesc", (void*)&RETVAL, sizeof(AESubDesc));
    }
    XSRETURN(1);
}

XS(XS_AEStream_Open)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: AEStream::Open()");
    {
	AEStream	RETVAL;
#line 1200 "AppleEvents.xs"
#ifdef MACOS_TRADITIONAL
	AEFail(AEStream_Open(&RETVAL));
#else
	RETVAL = AEStream_Open();
#endif
#line 1914 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEStream", (void*)&RETVAL, sizeof(AEStream));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CreateEvent)
{
    dXSARGS;
    if (items < 4 || items > 6)
	Perl_croak(aTHX_ "Usage: AEStream::CreateEvent(theClass, theID, addressType, address, returnID=kAutoGenerateReturnID, transactionID=0)");
    {
	OSType	theClass;
	OSType	theID;
	OSType	addressType;
	SV *	address = ST(3);
	short	returnID;
	long	transactionID;
	AEStream	RETVAL;

	memcpy(&theClass, SvPV_nolen(ST(0)), sizeof(OSType));

	memcpy(&theID, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&addressType, SvPV_nolen(ST(2)), sizeof(OSType));

	if (items < 5)
	    returnID = kAutoGenerateReturnID;
	else {
	    returnID = (short)SvIV(ST(4));
	}

	if (items < 6)
	    transactionID = 0;
	else {
	    transactionID = (long)SvIV(ST(5));
	}
#line 1224 "AppleEvents.xs"
	{
		char *		addressPtr;
		STRLEN		addressLen;
		AEDesc		targetDesc;
		AppleEvent	event;

		addressPtr = SvPV(address, addressLen);
		AEFail(AECreateDesc(addressType, addressPtr, addressLen, &targetDesc));
		if (gPAECreate)
			AEFail(
				CallOSACreateAppleEventProc(gPAECreate,
					theClass, theID, 
					&targetDesc, returnID, transactionID, &event, 
					gPAECreateRefCon));
		else
			AEFail(
				AECreateAppleEvent(
					theClass, theID, 
					&targetDesc, returnID, transactionID, &event));
		AEDisposeDesc(&targetDesc);
#ifdef MACOS_TRADITIONAL
		AEFail(AEStream_OpenEvent(&RETVAL, &event));
#else
		RETVAL = AEStream_OpenEvent(&event);
#endif
	}
#line 1979 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEStream", (void*)&RETVAL, sizeof(AEStream));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenEvent)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::OpenEvent(theEvent)");
    {
	AEDesc	theEvent;
	AEStream	RETVAL;

	if (sv_isa(ST(0), "AEDesc"))
	    memcpy(&theEvent, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEDesc));
	else
	    croak("theEvent is not of type AEDesc");
#line 1265 "AppleEvents.xs"
#ifdef MACOS_TRADITIONAL
	AEFail(AEStream_OpenEvent(&RETVAL, &theEvent));
#else
	RETVAL = AEStream_OpenEvent(&theEvent);
#endif
#line 2005 "AppleEvents.c"
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEStream", (void*)&RETVAL, sizeof(AEStream));
    }
    XSRETURN(1);
}

XS(XS_AEStream_Close)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::Close(stream)");
    {
	AEStream	stream;
	AEDesc	RETVAL;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1284 "AppleEvents.xs"
	AEFail(AEStream_Close(&stream, &RETVAL));
#line 2027 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	ST(0) = sv_newmortal();
	sv_setref_pvn(ST(0), "AEDesc", (void*)&RETVAL, sizeof(AEDesc));
    }
    XSRETURN(1);
}

XS(XS_AEStream_Abort)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::Abort(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1300 "AppleEvents.xs"
	RETVAL = AEStream_Close(&stream, nil);
#line 2052 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::OpenDesc(stream, type)");
    {
	AEStream	stream;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
#line 1325 "AppleEvents.xs"
	RETVAL = AEStream_OpenDesc(&stream, type);
#line 2079 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteData)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::WriteData(stream, data)");
    {
	AEStream	stream;
	SV *	data = ST(1);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1339 "AppleEvents.xs"
	{
		void *	ptr;
		STRLEN	length;

		ptr = SvPV(data, length);
		RETVAL = AEStream_WriteData(&stream, ptr, length);
	}
#line 2109 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CloseDesc)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::CloseDesc(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1359 "AppleEvents.xs"
	RETVAL = AEStream_CloseDesc(&stream);
#line 2133 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: AEStream::WriteDesc(stream, type, data)");
    {
	AEStream	stream;
	OSType	type;
	SV *	data = ST(2);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
#line 1374 "AppleEvents.xs"
	{
		void *	ptr;
		STRLEN	length;

		ptr = SvPV(data, length);
		RETVAL = AEStream_WriteDesc(&stream, type, ptr, length);
	}
#line 2166 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteAEDesc)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::WriteAEDesc(stream, desc)");
    {
	AEStream	stream;
	AEDesc	desc;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	if (sv_isa(ST(1), "AEDesc"))
	    memcpy(&desc, SvPV_nolen((SV*)SvRV(ST(1))), sizeof(AEDesc));
	else
	    croak("desc is not of type AEDesc");
#line 1395 "AppleEvents.xs"
	RETVAL = AEStream_WriteAEDesc(&stream, &desc);
#line 2196 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenList)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::OpenList(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1408 "AppleEvents.xs"
	RETVAL = AEStream_OpenList(&stream);
#line 2219 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CloseList)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::CloseList(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1428 "AppleEvents.xs"
	RETVAL = AEStream_CloseList(&stream);
#line 2242 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenRecord)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: AEStream::OpenRecord(stream, type=typeAERecord)");
    {
	AEStream	stream;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	if (items < 2)
	    type = typeAERecord;
	else {
	    memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
	}
#line 1441 "AppleEvents.xs"
	RETVAL = AEStream_OpenRecord(&stream, type);
#line 2272 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_SetRecordType)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::SetRecordType(stream, type)");
    {
	AEStream	stream;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&type, SvPV_nolen(ST(1)), sizeof(OSType));
#line 1455 "AppleEvents.xs"
	RETVAL = AEStream_SetRecordType(&stream, type);
#line 2298 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_CloseRecord)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: AEStream::CloseRecord(stream)");
    {
	AEStream	stream;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");
#line 1476 "AppleEvents.xs"
	RETVAL = AEStream_CloseRecord(&stream);
#line 2321 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteKeyDesc)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: AEStream::WriteKeyDesc(stream, key, type, data)");
    {
	AEStream	stream;
	OSType	key;
	OSType	type;
	SV *	data = ST(3);
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));
#line 1492 "AppleEvents.xs"
	{
		void *	ptr;
		STRLEN	length;

		ptr = SvPV(data, length);
		RETVAL = AEStream_WriteKeyDesc(&stream, key, type, ptr, length);
	}
#line 2357 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
	XSprePUSH; PUSHi((IV)!(gMacPerl_OSErr = (short)(RETVAL)));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OpenKeyDesc)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: AEStream::OpenKeyDesc(stream, key, type)");
    {
	AEStream	stream;
	OSType	key;
	OSType	type;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));

	memcpy(&type, SvPV_nolen(ST(2)), sizeof(OSType));
#line 1515 "AppleEvents.xs"
	RETVAL = AEStream_OpenKeyDesc(&stream, key, type);
#line 2387 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_WriteKey)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::WriteKey(stream, key)");
    {
	AEStream	stream;
	OSType	key;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
#line 1530 "AppleEvents.xs"
	RETVAL = AEStream_WriteKey(&stream, key);
#line 2413 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

XS(XS_AEStream_OptionalParam)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: AEStream::OptionalParam(stream, key)");
    {
	AEStream	stream;
	OSType	key;
	MacOSRet	RETVAL;
	dXSTARG;

	if (sv_isa(ST(0), "AEStream"))
	    memcpy(&stream, SvPV_nolen((SV*)SvRV(ST(0))), sizeof(AEStream));
	else
	    croak("stream is not of type AEStream");

	memcpy(&key, SvPV_nolen(ST(1)), sizeof(OSType));
#line 1546 "AppleEvents.xs"
	RETVAL = AEStream_OptionalParam(&stream, key);
#line 2439 "AppleEvents.c"
	sv_setref_pvn(ST(0), "AEStream", (void*)&stream, sizeof(AEStream));
	SvSETMAGIC(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Mac__AppleEvents)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("AEDesc::_new", XS_AEDesc__new, file);
        newXS("AEDesc::type", XS_AEDesc_type, file);
        newXS("AEDesc::data", XS_AEDesc_data, file);
        newXS("AEKeyDesc::_new", XS_AEKeyDesc__new, file);
        newXS("AEKeyDesc::key", XS_AEKeyDesc_key, file);
        newXS("AEKeyDesc::type", XS_AEKeyDesc_type, file);
        newXS("AEKeyDesc::data", XS_AEKeyDesc_data, file);
        newXS("Mac::AppleEvents::AECreateDesc", XS_Mac__AppleEvents_AECreateDesc, file);
        newXS("Mac::AppleEvents::AECoerce", XS_Mac__AppleEvents_AECoerce, file);
        newXS("Mac::AppleEvents::AECoerceDesc", XS_Mac__AppleEvents_AECoerceDesc, file);
        newXS("Mac::AppleEvents::AEDisposeDesc", XS_Mac__AppleEvents_AEDisposeDesc, file);
        newXS("Mac::AppleEvents::AEDuplicateDesc", XS_Mac__AppleEvents_AEDuplicateDesc, file);
        newXS("Mac::AppleEvents::AECreateList", XS_Mac__AppleEvents_AECreateList, file);
        newXS("Mac::AppleEvents::AECountItems", XS_Mac__AppleEvents_AECountItems, file);
        newXS("Mac::AppleEvents::AEPut", XS_Mac__AppleEvents_AEPut, file);
        newXS("Mac::AppleEvents::AEPutDesc", XS_Mac__AppleEvents_AEPutDesc, file);
        newXS("Mac::AppleEvents::AEPutKey", XS_Mac__AppleEvents_AEPutKey, file);
        newXS("Mac::AppleEvents::AEPutKeyDesc", XS_Mac__AppleEvents_AEPutKeyDesc, file);
        newXS("Mac::AppleEvents::AEGetNthDesc", XS_Mac__AppleEvents_AEGetNthDesc, file);
        newXS("Mac::AppleEvents::AEGetKeyDesc", XS_Mac__AppleEvents_AEGetKeyDesc, file);
        newXS("Mac::AppleEvents::AEDeleteItem", XS_Mac__AppleEvents_AEDeleteItem, file);
        newXS("Mac::AppleEvents::AEPutParam", XS_Mac__AppleEvents_AEPutParam, file);
        newXS("Mac::AppleEvents::AEPutParamDesc", XS_Mac__AppleEvents_AEPutParamDesc, file);
        newXS("Mac::AppleEvents::AEGetParamDesc", XS_Mac__AppleEvents_AEGetParamDesc, file);
        newXS("Mac::AppleEvents::AEDeleteParam", XS_Mac__AppleEvents_AEDeleteParam, file);
        newXS("Mac::AppleEvents::AEGetAttributeDesc", XS_Mac__AppleEvents_AEGetAttributeDesc, file);
        newXS("Mac::AppleEvents::AEPutAttribute", XS_Mac__AppleEvents_AEPutAttribute, file);
        newXS("Mac::AppleEvents::AEPutAttributeDesc", XS_Mac__AppleEvents_AEPutAttributeDesc, file);
        newXS("Mac::AppleEvents::AECreateAppleEvent", XS_Mac__AppleEvents_AECreateAppleEvent, file);
        newXS("Mac::AppleEvents::AESend", XS_Mac__AppleEvents_AESend, file);
        newXS("Mac::AppleEvents::AEResetTimer", XS_Mac__AppleEvents_AEResetTimer, file);
        newXS("Mac::AppleEvents::AESuspendTheCurrentEvent", XS_Mac__AppleEvents_AESuspendTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AEResumeTheCurrentEvent", XS_Mac__AppleEvents_AEResumeTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AEGetTheCurrentEvent", XS_Mac__AppleEvents_AEGetTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AESetTheCurrentEvent", XS_Mac__AppleEvents_AESetTheCurrentEvent, file);
        newXS("Mac::AppleEvents::AEGetInteractionAllowed", XS_Mac__AppleEvents_AEGetInteractionAllowed, file);
        newXS("Mac::AppleEvents::AESetInteractionAllowed", XS_Mac__AppleEvents_AESetInteractionAllowed, file);
        newXS("Mac::AppleEvents::AEInstallEventHandler", XS_Mac__AppleEvents_AEInstallEventHandler, file);
        newXS("Mac::AppleEvents::AERemoveEventHandler", XS_Mac__AppleEvents_AERemoveEventHandler, file);
        newXS("Mac::AppleEvents::AEGetEventHandler", XS_Mac__AppleEvents_AEGetEventHandler, file);
        newXS("Mac::AppleEvents::AEManagerInfo", XS_Mac__AppleEvents_AEManagerInfo, file);
        newXS("Mac::AppleEvents::AEBuild", XS_Mac__AppleEvents_AEBuild, file);
        newXS("Mac::AppleEvents::AEBuildParameters", XS_Mac__AppleEvents_AEBuildParameters, file);
        newXS("Mac::AppleEvents::AEBuildAppleEvent", XS_Mac__AppleEvents_AEBuildAppleEvent, file);
        newXS("Mac::AppleEvents::AEPrint", XS_Mac__AppleEvents_AEPrint, file);
        newXS("Mac::AppleEvents::AEDescToSubDesc", XS_Mac__AppleEvents_AEDescToSubDesc, file);
#if XSubPPtmpAAAA
        newXS("Mac::AppleEvents::AEGetSubDescType", XS_Mac__AppleEvents_AEGetSubDescType, file);
#endif
#if XSubPPtmpAAAB
        newXS("Mac::AppleEvents::AEGetSubDescType", XS_Mac__AppleEvents_AEGetSubDescType, file);
#endif
#if XSubPPtmpAAAC
        newXS("Mac::AppleEvents::AEGetSubDescBasicType", XS_Mac__AppleEvents_AEGetSubDescBasicType, file);
#endif
#if XSubPPtmpAAAD
        newXS("Mac::AppleEvents::AEGetSubDescBasicType", XS_Mac__AppleEvents_AEGetSubDescBasicType, file);
#endif
#if XSubPPtmpAAAE
        newXS("Mac::AppleEvents::AESubDescIsListOrRecord", XS_Mac__AppleEvents_AESubDescIsListOrRecord, file);
#endif
#if XSubPPtmpAAAF
        newXS("Mac::AppleEvents::AESubDescIsListOrRecord", XS_Mac__AppleEvents_AESubDescIsListOrRecord, file);
#endif
        newXS("Mac::AppleEvents::AEGetSubDescData", XS_Mac__AppleEvents_AEGetSubDescData, file);
        newXS("Mac::AppleEvents::AESubDescToDesc", XS_Mac__AppleEvents_AESubDescToDesc, file);
        newXS("Mac::AppleEvents::AECountSubDescItems", XS_Mac__AppleEvents_AECountSubDescItems, file);
        newXS("Mac::AppleEvents::AEGetNthSubDesc", XS_Mac__AppleEvents_AEGetNthSubDesc, file);
        newXS("Mac::AppleEvents::AEGetKeySubDesc", XS_Mac__AppleEvents_AEGetKeySubDesc, file);
        newXS("AEStream::Open", XS_AEStream_Open, file);
        newXS("AEStream::CreateEvent", XS_AEStream_CreateEvent, file);
        newXS("AEStream::OpenEvent", XS_AEStream_OpenEvent, file);
        newXS("AEStream::Close", XS_AEStream_Close, file);
        newXS("AEStream::Abort", XS_AEStream_Abort, file);
        newXS("AEStream::OpenDesc", XS_AEStream_OpenDesc, file);
        newXS("AEStream::WriteData", XS_AEStream_WriteData, file);
        newXS("AEStream::CloseDesc", XS_AEStream_CloseDesc, file);
        newXS("AEStream::WriteDesc", XS_AEStream_WriteDesc, file);
        newXS("AEStream::WriteAEDesc", XS_AEStream_WriteAEDesc, file);
        newXS("AEStream::OpenList", XS_AEStream_OpenList, file);
        newXS("AEStream::CloseList", XS_AEStream_CloseList, file);
        newXS("AEStream::OpenRecord", XS_AEStream_OpenRecord, file);
        newXS("AEStream::SetRecordType", XS_AEStream_SetRecordType, file);
        newXS("AEStream::CloseRecord", XS_AEStream_CloseRecord, file);
        newXS("AEStream::WriteKeyDesc", XS_AEStream_WriteKeyDesc, file);
        newXS("AEStream::OpenKeyDesc", XS_AEStream_OpenKeyDesc, file);
        newXS("AEStream::WriteKey", XS_AEStream_WriteKey, file);
        newXS("AEStream::OptionalParam", XS_AEStream_OptionalParam, file);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#line 2559 "AppleEvents.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

